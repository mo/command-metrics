#!/usr/bin/env python

# TODO:
# -- mark single metric as "bulk" (can run in parallel to others) or "perf" (must have machine to itself when it runs)
# -- re-run X times and save average
# -- make target attribute optional
# -- move legend to the right
# -- make color attribute optional (auto generate unique colors from nice scale)
# -- ability to zoom specific date range
# -- minimum_remeasurement_interval per metric
# -- thicker lines
# -- change "charts" in config to be an array
# -- Y value zoom

import os
import sys
import sets
import stat
import time
import shutil
import random
import pprint
import tempfile
import argparse
import datetime
import subprocess

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

def human_readable_time_span(seconds):
    if seconds < 0:
        return "-" + human_readable_time_span(-1*seconds)

    output = ""
    if seconds == 0 or seconds % 60 != 0:
        output = str(int(seconds % 60)) + "s"

    minutes = seconds // 60
    if minutes % 60 != 0:
        output = str(int(minutes % 60)) + "m" + output

    hours = minutes // 60
    if hours % 24 != 0:
        output = str(int(hours % 24)) + "h" + output

    days = hours // 24
    if days != 0:
        output = str(int(days)) + "d" + output

    return output

def measure_metric(config, metric_name, target):
    metric = config["metrics"][metric_name]
    command_template = metric["cmd"]
    if args.debug:
        print "[DEBUG] command template: " + command_template
    try:
        metric_command = command_template % { "target": target }
    except:
        print "[ERROR] Invalid command template for metric '%s'." % metric_name
        print "[NOTE] % must be escaped as %% and target should be referred to as %(target)s"
        print "[NOTE] Offending command template was: " + command_template
        sys.exit(1)
    if args.debug:
        print "[DEBUG] about to run command: " + metric_command
    child_env = os.environ.copy()
    child_env["PATH"] = os.path.join(SCRIPT_DIR, "metric-scripts") + ":" + child_env["PATH"]

    external_scripts_dir = os.path.join(SCRIPT_DIR, "../../external-metric-scripts")
    if os.path.exists(external_scripts_dir):
        if args.debug:
            print "[DEBUG] adding '%s' to PATH" % external_scripts_dir
        child_env["PATH"] = external_scripts_dir + ":" + child_env["PATH"]

    stdout_output = subprocess.check_output(metric_command, env=child_env, shell=True).strip()
    if args.debug:
        print "[DEBUG] value (from stdout) was: " + repr(stdout_output)
    value = float(stdout_output)
    if "throttle_sleep_seconds" in metric:
        if args.force_sleep != None:
            throttle_sleep_seconds = args.force_sleep
        else:
            throttle_sleep_seconds = float(metric["throttle_sleep_seconds"])
        if args.debug:
            if ("%.3f" % throttle_sleep_seconds).endswith(".000"):
                sleep_time_str = "%.0f" % throttle_sleep_seconds
            else:
                sleep_time_str = "%.3f" % throttle_sleep_seconds
            print "[DEBUG] throttle sleeping for %s seconds" % sleep_time_str
        time.sleep(throttle_sleep_seconds)
    if args.debug:
        print ""
    return value


class MeasuredData(object):
    # self.datapoints is a dict in which metric_name maps to a dict,
    #                           in which target maps to array of object containing
    #                           { "timestamp": ..., "value": ..., }.

    def __init__(self, data_filename):
        self.data_filename = data_filename

        if os.path.exists(self.data_filename):
            self.datapoints = eval(open(self.data_filename).read())
        else:
            self.datapoints = {}

    def save_to_disk(self):
        string_data = pprint.pformat(self.datapoints)
        with open(self.data_filename, "w") as f:
            f.write(string_data + "\n")

    def delete_data_for_metric(self, metric_name):
        if metric_name in self.datapoints:
            del self.datapoints[metric_name]

    def add_data(self, metric_name, target, value):
        metric_data = self.datapoints.setdefault(metric_name, {}).setdefault(target, [])
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        new_datapoint = { "timestamp": timestamp, "value": value }
        metric_data.append(new_datapoint)

class JsData(object):
    def __init__(self, config, measured_data, jsdata_filename):
        self.config = config
        self.measured_data = measured_data
        self.jsdata_filename = jsdata_filename

    def save_to_disk(self):
        jsdata_tempfile_oshandle, jsdata_tempfile_name = tempfile.mkstemp()
        with open(jsdata_tempfile_name, "w") as jsdata_temp_file:
            jsdata_temp_file.write("allChartData = [\n")
            for chart_name, chart in self.config["charts"].iteritems():
                jsdata_temp_file.write("{\n")
                jsdata_temp_file.write("  'chartKey': '%s',\n" % chart_name)
                jsdata_temp_file.write("  'chartTitle': '%s',\n" % chart["chart_title"])
                jsdata_temp_file.write("  'chartSeries': [\n")
                for chart_series in chart["chart_series"]:
                    metric_name = chart_series["metric"]
                    target = chart_series.get("target", None)
                    series_data = self.measured_data.datapoints.get(metric_name, {}).get(target, [])
                    if series_data:
                        metric = self.config["metrics"][metric_name]
                        jsdata_temp_file.write("            {\n")
                        series_title = metric["title"] % { "target": target }
                        jsdata_temp_file.write("              'seriesTitle': '%s',\n" % series_title)
                        jsdata_temp_file.write("              'seriesColor': '%s',\n" % chart_series["color"])
                        x_values = []
                        y_values = []
                        for datapoint in series_data:
                            x_values.append(datapoint["timestamp"])
                            y_values.append(datapoint["value"])
                        quoted_x_values = ",".join(map(lambda val: "'" + str(val) + "'", x_values))
                        quoted_y_values = ",".join(map(lambda val: "'" + str(val) + "'", y_values))
                        jsdata_temp_file.write("              'xValues': [\n")
                        jsdata_temp_file.write("                %s\n" % quoted_x_values)
                        jsdata_temp_file.write("              ],\n")
                        jsdata_temp_file.write("              'yValues': [\n")
                        jsdata_temp_file.write("                %s\n" % quoted_y_values)
                        jsdata_temp_file.write("              ],\n")
                        jsdata_temp_file.write("            },\n")
                jsdata_temp_file.write("  ]\n")
                jsdata_temp_file.write("},\n")

            jsdata_temp_file.write("]\n")

        os.close(jsdata_tempfile_oshandle)
        shutil.move(jsdata_tempfile_name, self.jsdata_filename)
        os.chmod(self.jsdata_filename, stat.S_IRUSR | stat.S_IWUSR | stat.S_IROTH)

def refresh_measurements(config, measured_data, jsdata):
    # If "--metric foo --metric yada" is passed, then only refresh measurements
    # for those metrics, if no such argument is passed "selected_metrics" will
    # be set to None and measurements for all metrics will be done.
    selected_metrics = args.metric

    todo_list = sets.Set()
    for chart_name, chart in config["charts"].iteritems():
        for series in chart["chart_series"]:
            metric_name = series["metric"]
            target = series.get("target", None)
            if not selected_metrics or metric_name in selected_metrics:
                todo_list.add((metric_name, target))
    todo_len = len(todo_list)
    if args.debug:
        print "[DEBUG prepared todo list of %d things to measure" % todo_len

    for (idx, (metric_name, target)) in enumerate(todo_list):
        if not args.quiet:
            print_dict = {
                "current": idx+1,
                "total": todo_len,
                "metric_name": metric_name,
                "target": target,
            }
            if target:
                print "[%(current)d/%(total)d] measuring '%(metric_name)s' for '%(target)s'" % print_dict
            else:
                print "[%(current)d/%(total)d] measuring '%(metric_name)s'" % print_dict
        value = measure_metric(config, metric_name, target)
        measured_data.add_data(metric_name, target, value)
        measured_data.save_to_disk()
        jsdata.save_to_disk()

def main():
    config = eval(open(os.path.join(SCRIPT_DIR, "..", "..", "config.pyon")).read())
    data_filename = os.path.join(SCRIPT_DIR, "..", "..", "data.pyon")
    jsdata_filename = os.path.join(SCRIPT_DIR, "..", "..", "allChartData.js")

    measured_data = MeasuredData(data_filename)
    jsdata = JsData(config, measured_data, jsdata_filename)

    if args.jsdata_only:
        jsdata.save_to_disk()
    elif args.list_metrics:
        for metric_name in config["metrics"]:
            print metric_name
    elif args.delete_data_for_metric:
        measured_data.delete_data_for_metric(args.delete_data_for_metric)
        measured_data.save_to_disk()
        jsdata.save_to_disk()
    else:
        measurement_start_time = datetime.datetime.now()
        refresh_measurements(config, measured_data, jsdata)
        measurement_stop_time = datetime.datetime.now()
        measurement_seconds = (measurement_stop_time - measurement_start_time).total_seconds()
        if not args.quiet:
            print "Measurement started: " + str(measurement_start_time)[:19]
            print "Measurement stopped: " + str(measurement_stop_time)[:19]
            print "Measurement took: " + human_readable_time_span(measurement_seconds)

if __name__ == '__main__':
    try:
        parser = argparse.ArgumentParser()
        parser.add_argument("-q", "--quiet", action="store_true")
        parser.add_argument("-d", "--debug", action="store_true")
        parser.add_argument("-s", "--force-sleep", metavar="SECONDS", type=float)
        parser.add_argument("-j", "--jsdata-only", action="store_true")
        parser.add_argument("-l", "--list-metrics", action="store_true")
        parser.add_argument("--delete-data-for-metric", metavar="METRIC_NAME", type=str)
        parser.add_argument("-m", "--metric", action="append")
        args = parser.parse_args()

        main()

    except KeyboardInterrupt:
        print
        pass
